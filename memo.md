## Next.js とは

React のフレームワーク
React に必要な構成を自動的に行う。それにより、我々はアプリケーションの構築に集中できる。

左のナビゲーションに従えば、初級から上級まで順番に学べるようだ。

## 今回は、Pages Router について学ぶ

## サーバーコンポーネント

サーバーコンポーネントは、サーバー上でレンダリングされ、その結果がクライアントに送信される React コンポーネントのことを指します。
開発者はサーバー インフラストラクチャをより効果的に活用できるようになります。
非対話型であるなら、サーバー上でサーバー コンポーネントとしてレンダリングするとクライアントサイドで余計な js を走らせなくて済む。

- インフラストラクチャ
  - サーバー、ネットワーク、ストレージなどなど。
- データの取得を DB に近いサーーバーに移動したり
- バンドルサイズを小さくしたり.

サーバーコンポーネントは Ruby on Rails や php に似ている。

## 最初のページ読み込みが早くなる

- js のバンドルサイズが小さくなるから。
- サーバーコンポーネントが大きくなっても、クライアント側の js ランタイムは大きくならない。

## Next.js のページがユーザーに届くまで

- ユーザーがページを要求すると、Next.js は最初にサーバーサイドでページをレンダリングします（これは SSR）。
- レンダリングされた静的 HTML はクライアント（ユーザーのブラウザ）に送信され、すぐに表示されます。これにより、ユーザーはページをすぐに見ることができます。
- 送信された HTML には、ページのインタラクティブな部分を動作させるために必要な JavaScript コード（通常は React コンポーネント）のリンクが含まれています。
- ブラウザはこの JavaScript を非同期にダウンロードし、実行します（これは CSR）。これにより、ページはインタラクティブになります。

## SSR と CSR のコンポーネントは親子関係におかない

- CSR コンポーネントはサーバーサイドレンダリング（SSR）コンポーネントを子として持つことはできない。
- その場合は親子関係でなく、兄弟関係として component を置くのが良い
- リーフにクライアントコンポーネントを配置することで、サーバーコンポーネントが事前にレンダリングできる部分が増え、全体のパフォーマンスを向上させることが可能になります

## process.env.hoge の命名規則

process.env.NREXT_PUBLIC_API_KEY //クライアントでも動く
authorization: process.env.API_KEY, //サーバー上のみ

## データのフェッチ

SSR でできるならそっちで行う！

## サーバーコンポーネント内でクライアントコンポーネントを使う

client component の中に Server component は入れる
しかしその逆はダメ。
理由は SSR 時に clientcomponent に含まれる対話部分はレンダリングできないため。

"use client"を使用してコンポーネント化して入れる事ができれば、SSR に含めず CSR に渡せる。

```jsx
//クライアントコンポーネントでラップする。
//Carousel.tsx
"use client"
import {Carousel} from "hoge"
export default Carousel

//page.tsx
import Carousel from "./carousel"
export default function Page(){
  return <Carousel />
}

```

## サーバーコンポーネントでのサードパーティコンテキストプロバイダーのレンダリング

サーバーコンポーネント内で使用したいときは、1 度 use Client が必要.
componentn をラッピングして使用すれば OK

## layout は page ではないので、getStaticProps や、getServerSideProps が使えない。

そのため、useEffec や useSWR を使用する。
